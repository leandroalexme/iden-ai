import {
    a as n
} from "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-BJKDAX5B.js";
import {
    a as p,
    b as I
} from "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-Y7G475Z7.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-PJEQGESF.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-VBQ72NC4.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-RDXN3NMA.js";
import {
    a as C
} from "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-CKEDNR4Z.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-NRKM3O27.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-UT22G6CJ.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-O454CSQB.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-KSXA7H77.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-VFUQL75R.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-N2N7GOUG.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-7TFJVZMD.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-2M3GYHUW.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-ZJMKULCD.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-3HBNHCFR.js";
import {
    d as m,
    g as S
} from "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-HQUF2BFY.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-MWTOBXCT.js";
import {
    a as d,
    b as M
} from "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-K4MSOFN3.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-OQWTLMV5.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-BBGOCAHY.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-YZMXGORB.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-VCWMZ4MQ.js";
import {
    a as T
} from "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-TCPTYTUX.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-BVZRGHXD.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-LFUSN6Y5.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-XGXYOKTY.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-I6JNYDBX.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-ZCYSW665.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-LY4A4ZCW.js";
import {
    a as b
} from "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-QXKVEKVP.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-OQTCXMQ2.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-YNQJOZVU.js";
import {
    D as a,
    F as g
} from "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-6YK6Y3LS.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-X2AVVSDG.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-ESPTCIFT.js";
import {
    q as c,
    r as v
} from "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-GYU6G37N.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-7GYVYFTN.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-FX3USXD4.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-LURZCKUX.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-UHXY36KN.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-ISPIXJKU.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-JIE3ALW5.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-33VGZGAT.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-ILD4NFNU.js";
import "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-BXWTANI3.js";
import {
    d as l
} from "https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-64BUEHBL.js";
var u = l(b());
var h = l(T());
S();
I();
C();
M();
v();
g();
var w = n.extend({
        triggerWidgets: [],
        initialize: function(e, s, t) {
            this.model = new h.default.Model(e), this.isAllImagesLoaded = !1, n.prototype.initialize.apply(this, [e, s, t])
        },
        render: async function() {
            if (!this.basePath || !this.numberOfImages) return this;
            this.makeBox("widget-shots");
            let {
                renderReact: e
            } = await
            import ("https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-LKSFPTWI.js"), {
                Shots: s
            } = await
            import ("https://st-p.rmcdn1.net/ae5fa58f/dist/c/c-7FOUNMKD.js");
            return this.stateModel = new h.default.Model(this.getCurrentState()), e({
                component: () => a(m, {
                    context: p,
                    model: this.stateModel,
                    children: a(s, {
                        mode: window.RM.screenshot ? "screenshoter" : "viewer",
                        onFirstRender: this.onFirstRender,
                        onFirstFrameLoaded: this.widgetIsLoaded,
                        onAllImagesLoaded: this.onAllImagesLoaded
                    })
                }),
                domElement: this.el,
                model: this.model,
                onDestroy: () => {
                    let i = this.el;
                    u.default.unmountComponentAtNode(i), i && i.parentNode && i.parentNode.removeChild(i)
                }
            }), this.checkLink(), this
        },
        getCurrentState: function() {
            return {
                pageScale: this.page.scale,
                pageContentTop: this.page.contentPosition.top,
                magContainerHeight: this.page.mag.getContainerSizeCached().height,
                widgetBoxTop: this.calcBoxStyle({
                    calcBBox: !0
                }).dimensions.top
            }
        },
        getViewerType: function() {
            return this.page.mag && this.page.mag.viewOpts && this.page.mag.viewOpts.viewertype || "vertical"
        },
        onFirstRender: function() {
            if (this.rendered = !0, this._scheduleStart && this.start(), this.playbackType === "scroll") {
                let e;
                this.isAbove() && this.getViewerType() === "vertical" ? e = this.page.mag.getScroll() : e = this.page.getScroll(), this.handleScroll(e)
            }
        },
        handleScroll: function(e) {
            this.rendered && this.stateModel.set({ ...this.getCurrentState(),
                currentScrollOffset: e
            })
        },
        handlePointerMovement: function(e) {
            if (!this.rendered) return;
            "touches" in e && this.getViewerType() === "horizontal" && this.hoverDirection === "horizontally" && e.stopPropagation();
            let s = "touches" in e ? e.touches[0].clientX : e.clientX,
                t = "touches" in e ? e.touches[0].clientY : e.clientY,
                i = e.target;
            if (!i) return;
            let o = c.getDocumentBox(i),
                r = d.isCSSTransform() ? 1 : this.page.scale,
                f = s / r - o.left,
                y = t / r - o.top;
            this.hoverDirection === "horizontally" ? this.stateModel.set({
                hoverPercent: f / o.width
            }) : this.hoverDirection === "vertically" && this.stateModel.set({
                hoverPercent: y / o.height
            })
        },
        getTriggerWidgets: async function() {
            let e = [];
            for (let s of this.triggers) {
                let t;
                try {
                    t = await this.page.mag.getWidgetById(s, this.page)
                } catch {
                    continue
                }
                t && (t.rendered || await new Promise(i => this.listenToOnce(t, "rendered", i)), e.push(t))
            }
            return e.length || e.push(this), e
        },
        async bindTriggers(e, s) {
            this.triggerWidgets = await this.getTriggerWidgets(), this.triggerWidgets.forEach(t => {
                if (t.el instanceof HTMLElement)
                    for (let i of e) t.el.addEventListener(i, s)
            })
        },
        unbindTriggers(e, s) {
            this.triggerWidgets.forEach(t => {
                if (t.el instanceof HTMLElement)
                    for (let i of e) t.el.removeEventListener(i, s)
            })
        },
        handleContext(e) {
            e.preventDefault()
        },
        handlePointerHover(e) {
            e.type === "touchstart" && e.target.setAttribute("draggable", "true"), (e.type === "touchend" || e.type === "touchcancel") && e.target.removeAttribute("draggable"), this.stateModel.set({
                mouseIn: e.type === "mouseenter" || e.type === "touchstart"
            })
        },
        handleMouseHoverInitCursor(e) {
            let s = e.target;
            if (s) {
                let t = s.getBoundingClientRect(),
                    i = e.pageX >= t.x && e.pageX <= t.x + t.width,
                    o = e.pageY >= t.y && e.pageY <= t.y + t.height,
                    r = i && o;
                this.stateModel.set({
                    mouseIn: r
                }), this.unbindTriggers(["mousemove"], this.handleMouseHoverInitCursor)
            }
        },
        handleClick() {
            this.stateModel.set({
                mouseIn: !this.stateModel.get("mouseIn")
            })
        },
        onAllImagesLoaded() {
            this.isAllImagesLoaded = !0, this.playbackType === "hover" ? (this.bindTriggers(["mouseenter", "mouseleave", "touchstart", "touchend", "touchcancel"], this.handlePointerHover), Modernizr.ismobile && this.bindTriggers(["contextmenu"], this.handleContext)) : this.playbackType === "click" && this.bindTriggers(["click"], this.handleClick).then(() => {
                this.triggerWidgets.forEach(e => {
                    e.el instanceof HTMLElement && e.el.classList.add("interactive")
                })
            })
        },
        start: function(...e) {
            if (n.prototype.start.apply(this, e), !this.rendered) {
                this._scheduleStart = !0;
                return
            }
            this.playbackType === "scroll" ? this.isAbove() && this.getViewerType() === "vertical" ? this.listenTo(this.page.mag, "mag_scroll", this.handleScroll) : this.listenTo(this.page, "page_scroll", this.handleScroll) : (this.playbackType === "hover" && this.pausable === void 0 || this.playbackType === "mousemove") && this.bindTriggers(["mousemove", "touchmove"], this.handlePointerMovement), setTimeout(() => {
                this.stateModel.set({
                    isStarted: !0
                })
            }, 1), this.isAllImagesLoaded && this.onAllImagesLoaded()
        },
        stop: function(...e) {
            n.prototype.stop.apply(this, e), this.rendered && (this.stopListening(), this.unbindTriggers(["mousemove", "touchmove"], this.handlePointerMovement), this.unbindTriggers(["mouseenter", "mouseleave", "touchstart", "touchend", "touchcancel"], this.handlePointerHover), this.unbindTriggers(["contextmenu"], this.handleContext), this.unbindTriggers(["click"], this.handleClick), this.stateModel.set({
                isStarted: !1
            }))
        },
        destroy: function(...e) {
            n.prototype.destroy.apply(this, e)
        }
    }),
    B = w;
export {
    B as
    default
};